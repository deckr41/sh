#!/usr/bin/env sh

# DESCRIPTION
#  Internal subcommand for validating a prompt JSON payload based on the
#  SH41 conversation schema.
#
# ERROR CODES
#  1 - JSON validation error 
#
# SEE ALSO
#  jq(1)

CMD_NAME="sh41-prompt-validate"

# ╭───┤ Functions
# ╰─

# Redirect stdin from /dev/tty to ensure it's treated as interactive
# and not inherited from parent's stdin
log_error() { "$SH41_UTILS"/log "$@" "$CMD_NAME" < /dev/tty; }

# TODO: Consider using 3rd party JSON schema validation library
validate_input_json() {
  jq '
    # Reusable predicates
    def isString: type == "string";
    def isArray: type == "array";
    def exists: . != null;

    # Error handlers
    def typeError(field; expectedType): "Invalid type for field: " + field + ". Expected: " + expectedType;
    def notFoundError(key): "Missing key: " + key;

    if .conversation_id | exists | not then
      notFoundError("conversation_id")
    elif .conversation_id | isString | not then
      typeError("conversation_id"; "string")
    elif .messages | exists | not then
      notFoundError("messages")
    elif .messages | isArray | not then
      typeError("messages"; "array")
    else
      empty
    end' < /dev/stdin
}

# ╭───┤ Dependency check
# ╰─

if ! command -v "jq" >/dev/null 2>&1; then
  log_error "jq is required to run this script"
  exit 1
fi

# ╭───┤ Input validation 
# ╰─

if [ -t 0 ]; then
  log_error "No input provided, expected JSON payload on stdin"
  exit 1
fi

# ╭───┤ Main
# ╰─

input_stdin_file=$(mktemp)
cat > "$input_stdin_file"

cleanup() {
  exit_code=$?
  rm -f "$input_stdin_file"
  exit $exit_code
}
trap cleanup EXIT

error_message=$(validate_input_json 2>&1 < "$input_stdin_file")
if [ -n "$error_message" ]; then
  log_error "$error_message"
  exit 3
fi

cat "$input_stdin_file"
