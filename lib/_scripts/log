#!/usr/bin/env sh

# NAME
#  log - Print a fancy log message
#
# SYNOPSIS
#  log <type> [-nc|--no-color] [-v|--var <name> <value>] <message>
#
# FLAGS
#  [-ns|--no-color]
#   Do not print colors or icons.
#   Defaults to true if the CI environment variable is set, otherwise false.
#
# OPTIONS
#  [-v|--var <name> <value>]
#   Print a variable name and its value, nicely formatted and color coded,
#   after the message text.
#
# ARGUMENTS
#  <type>
#   The type of message to print. Possible values are "error", "warning",
#   "info", and "success".
#
#  <message>
#   The message to print. Can be passed as the first argument or as 
#   standard input.
#
# ENVIRONMENT
#  LOG_LEVEL
#   The minimum level of log messages to print. Possible values are "error",
#   "warning" and "info" ("success" messages will always be printed).
#   Defaults to "error".
#
#  LOG_NAMESPACE
#   If set, the namespace is printed before the message.
#
#  CI
#   If set, messages are printed without colors.

# ╭───┤ Bootstrap
# ╰─

LOG_NAMESPACE=${LOG_NAMESPACE:-}
LOG_LEVEL=${LOG_LEVEL:-error}

# ╭───┤ Functions
# ╰─

set_theme() {
  TYPE_LABEL="ERR"
  TYPE_COLOR="red"

  case $1 in
    err|error) TYPE_LABEL="ERR"; TYPE_COLOR="red" ;;
    warn|warning) TYPE_LABEL="WRN"; TYPE_COLOR="yellow" ;;
    info) TYPE_LABEL="INF"; TYPE_COLOR="blue" ;;
    success) TYPE_LABEL="SUC"; TYPE_COLOR="green" ;;
  esac
}

log_plain() {
  echo "$(date +%T) $TYPE_LABEL ${LOG_NAMESPACE:+$LOG_NAMESPACE: }$1 $2"
}

log_with_style() {
  styled_type_label=$(color "$TYPE_COLOR" "$(stylize bold "$TYPE_LABEL")")

  if [ -n "$LOG_NAMESPACE" ]; then
    styled_namespace=$(color gray "$LOG_NAMESPACE: ")
  fi

  echo "$(date +%T) $styled_type_label $styled_namespace$1 $2"
}

should_print() {
  case $LOG_LEVEL in
    err|error) [ "$1" = "error" ] || [ "$1" = "err" ] || [ "$1" = "success" ] ;;
    warn|warning) [ "$1" = "error" ] || [ "$1" = "err" ] || [ "$1" = "warning" ] || [ "$1" = "warn" ] || [ "$1" = "success" ] ;;
    info) [ "$1" = "error" ] || [ "$1" = "err" ] || [ "$1" = "warning" ] || [ "$1" = "warn" ] || [ "$1" = "info" ] || [ "$1" = "success" ] ;;
  esac
}

# ╭───┤ Argument parsing
# ╰─

message_type=$1; 
if [ -z "$message_type" ]; then
  echo "No message type provided" >&2
  exit 1
fi
shift

if ! should_print "$message_type"; then
  exit 0
fi

has_color=$([ -n "$CI" ] && echo "" || echo "true")
variables=""

while [ "$#" -gt 0 ]; do
  case $1 in
    -nc|--no-color) has_color=""; shift ;;
    -v|--var)
      if [ "$2" ]; then
        key=$2; shift
      else
        echo "-v|--var option requires a key" >&2
        exit 1
      fi

      if [ "$2" ]; then
        value="$2"; shift
      fi

      if [ -n "$has_color" ]; then
        variables="$variables$(color gray "$key=")$value "
      else 
        variables="$variables $key=$value"
      fi
      shift
    ;;
    --) shift; break ;;
    -*) echo "Unknown parameter $1" >&2; exit 1 ;;
    *) break ;;
  esac
done

# ╭───┤ Main
# ╰─

set_theme "$message_type"

if [ -z "$has_color" ]; then
  log_plain "$1" "$variables" >&2
else
  log_with_style "$1" "$variables" >&2
fi

