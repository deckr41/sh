#!/usr/bin/env sh

# NAME
#  log - Print a fancy log message
#
# SYNOPSIS
#  log <type> [-nc|--no-color] <message>
#
# FLAGS
#  [-ns|--no-color]
#   Do not print colors or icons.
#
# ARGUMENTS
#  <type=error>
#   The type of message to print. Possible values are "error", "warning",
#   "info", and "success". Default is "error".
#
#  <message>
#   The message to print. Can be passed as the first argument or as 
#   standard input.
#
# ENVIRONMENT
#  LOG_NAMESPACE
#   If set, the namespace is printed before the message.
#
#  CI
#   If exists, the message is printed without colors.

# ╭───┤ Functions
# ╰─

set_theme() {
  TYPE_LABEL="ERR"
  TYPE_COLOR="red"

  case $1 in
    err|error) TYPE_LABEL="ERR"; TYPE_COLOR="red" ;;
    warn|warning) TYPE_LABEL="WRN"; TYPE_COLOR="yellow" ;;
    info) TYPE_LABEL="INF"; TYPE_COLOR="blue" ;;
    success) TYPE_LABEL="SUC"; TYPE_COLOR="green" ;;
  esac
}

log_plain() {
  echo "$(date +%T) $TYPE_LABEL ${LOG_NAMESPACE:+$LOG_NAMESPACE: }$1"
}

log_with_style() {
  styled_type_label=$(color "$TYPE_COLOR" "$(stylize bold "$TYPE_LABEL")")

  if [ -n "$LOG_NAMESPACE" ]; then
    styled_namespace=$(color gray "$LOG_NAMESPACE: ")
  fi

  echo "$(date +%T) $styled_type_label $styled_namespace$1"
}

# ╭───┤ Argument parsing
# ╰─

message_type=${1:-error}; shift
has_color=$([ -n "$CI" ] && echo "" || echo "true")

while [ "$#" -gt 0 ]; do
  case $1 in
    -nc|--no-color) has_color=""; shift ;;
    *) break ;;
  esac
done

# ╭───┤ Main
# ╰─

set_theme "$message_type"

if [ -z "$has_color" ]; then
  log_plain "$1" >&2
else
  log_with_style "$1" >&2
fi

